# Minibank on Slackware

NOTE (2020-09-12): Work in progress, doc started
NOTE (2020-11-22): Whis work is not finished and not clear if this would even work. I did not go far enough to know for sure it this will work.

UPDATE 2020-09-29: Not able to build bitcoin https://github.com/bitcoin/bitcoin/issues/20038 . Likely because binaries are not 64-bit and have to do this cross compilation https://docs.slackware.com/howtos:hardware:arm:gcc-9.x_aarch64_cross-compiler to get to 64-bit

Instructions on how to install the same hardware and software as https://github.com/alevchuk/minibank yet on Slackware operating system. The advantage of Slackware is it's design philosophy of keeping packages simple with as little modifications to upstream as possible.


Minibank currently uses the Rasbian operating system, however setting it up on Slackware would provide several advantages:
- No middleman for OS distribution (Debian -> Rasbian) - reduces changes of supply chain attacks
- Focus on simplicity. E.g. less packages and less changes, resulting in a smaller to [Slacker Security Advisory](http://www.slackware.com/security/list.php?l=slackware-security&y=2020) as compared to [Debian Security Advisory](https://www.debian.org/security/2020/)


## Install Slackware (without a Raspbian image)

Follow official instructions: https://docs.slackware.com/howtos:hardware:arm:raspberrypi4#manual_install_method_without_a_raspbian_image

Here are small modification to the script that makes things safer (by using /dev/sda2 instead your root disk, enable error checking in bash)
 
* In step 2 (Put the Raspberry Pi firmware in the SD Card):
```bash
#!/bin/bash

set -e
set -o
set -u
set -x

mkdir -p ~/mnt

git clone https://github.com/raspberrypi/firmware.git
sudo mount /dev/sda1 ~/mnt
sudo cp -r firmware/boot/* ~/mnt
sudo umount ~/mnt
sudo mount /dev/sda2 ~/mnt
sudo mkdir -p ~/mnt/lib/modules
sudo cp -r firmware/modules/* ~/mnt/lib/modules
sudo umount ~/mnt
```


* In step 3 (putting Slackware ARM mini root file system in the SD Card),:
  1. Set the temporary password (PASSWD) to something unique for good measure.
```bash
#!/bin/bash

set -e
set -o
set -u
set -x

mkdir -p ~/mnt

wget -c ftp://ftp.arm.slackware.com/slackwarearm/slackwarearm-devtools/minirootfs/roots/slack-14.2-miniroot_01Jul16.tar.xz
sudo mount /dev/sda2 ~/mnt
sudo tar -C ~/mnt -xf slack-14.2-miniroot_01Jul16.tar.xz
echo "/dev/mmcblk0p1 /boot vfat defaults 0 0" | sudo tee ~/mnt/etc/fstab
echo "/dev/mmcblk0p2 /     ext4 defaults 0 0" | sudo tee -a ~/mnt/etc/fstab
echo "proc           /proc proc defaults 0 0" | sudo tee -a ~/mnt/etc/fstab
PASSWD=$(openssl passwd -1 -salt cetkq/enZx6/c2 temporary_password_goes_here)
sudo sed -i "s|\(root:\).*\(:16983:0:::::\)|\1${PASSWD}\2|" ~/mnt/etc/shadow
sudo sed -i 's|USE_DHCP\[1\]=""|USE_DHCP\[1\]="yes"|' ~/mnt/etc/rc.d/rc.inet1.conf
echo "PermitRootLogin yes" | sudo tee -a ~/mnt/etc/ssh/sshd_config
sudo umount ~/mnt
```

* TODO: Somewhere in between steps 2 and 3, figure out a way to install "screen" because step 3 takes a long time and you could get disconnected.

# Enable vi

```
rm /usr/bin/vi
ln -s /usr/bin/vim /usr/bin/vi
```

# Update

1. Uncomment a single URL in the file `/etc/slackpkg/mirrors`
2. Run `slackpkg update gpg`
3. Run `slackpkg update`

Instructions on how to use package managers are here https://docs.slackware.com/slackware:slackpkg

# Create user

1. New user
```
adduser pi
```

2. Create sudoers group
* run `vigr`
* add `sudo:x:1000:pi` at the end of the file

3. Give sudo to user
* run `visudo` and uncomment sudoers part, add "NOPASSWD:" so you don't have to retype password every time


# Disable SSH root login

1. Run `sudo vi /etc/ssh/sshd_config` and comment out `PermitRootLogin yes`
2. Run `sudo /etc/rc.d/rc.sshd restart`

# Remove root password

1. Run `sudo  vipw -s`
2. Replace `root:something_is_here:` with `root:*:`


# Firewall

1. Run
```
sudo mkdir /etc/sysconfig
sudo vi /etc/sysconfig/iptables
```
and copy-paste the following
```
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -i lo -j ACCEPT
-A OUTPUT -o lo -j ACCEPT
-A INPUT -p tcp --dport 22 -j ACCEPT
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
COMMIT
```


2. Generate firewall script form here http://www.slackware.com/~alien/efg/ (be warned, it's not HTTPS).

You can just use the copy of the script provided bellow.

The script provided bellow is a truncated copy on the ~alien/efg script with a modification to have "start" and "restore" be the same thing. If you want to use the original version that has a more complicated "start" function, make sure to add "Allow Inbound Services" -> SSH


3. Run `sudo vi /etc/rc.d/rc.firewal`
4. Paste the script
5. `sudo chmod +x /etc/rc.d/rc.firewall`
6. `sudo /etc/rc.d/rc.firewall restore`
7. Check with `sudo iptables-save`
8. Reboot and check again

```bash
#!/bin/sh
#
# Generated iptables firewall script for the Linux 2.4 kernel and later.
# Script generated by Easy Firewall Generator for IPTables 1.15
# copyright 2002 Timothy Scott Morizot
# Modified for Slackware Linux by Eric Hameleers <alien@slackware.com>
# 
# This generator is adapted from the original to work on Slackware Linux.
# Basically, I corrected the path name to the iptables* commands
# and re-wrote this comment.
#
# It can be executed with the typical start and stop arguments.
# If used with stop, it will stop after flushing the firewall.
# The save and restore arguments will save or restore the rules
# from the /etc/sysconfig/iptables file.  The save and restore
# arguments are included to preserve compatibility with
# Redhat's or Fedora's init.d script if you prefer to use it.

# You may want to save this script as /etc/rc.d/rc.firewall
# and make it executable, like this:
#   chmod +x /etc/rc.d/rc.firewall
# Slackware Linux will then automatically run this script
# with the "start" parameter.

###############################################################################

# IPTables Location - adjust if needed

IPT="/usr/sbin/iptables"
IPTS="/usr/sbin/iptables-save"
IPTR="/usr/sbin/iptables-restore"

# Save and Restore arguments handled here
if [ "$1" = "save" ]
then
	echo -n "Saving firewall to /etc/sysconfig/iptables ... "
	$IPTS > /etc/sysconfig/iptables
	echo "done"
	exit 0
elif [ "$1" = "restore" ] ||  [ "$1" = "start" ] 
then
	echo -n "Restoring firewall from /etc/sysconfig/iptables ... "
	$IPTR < /etc/sysconfig/iptables
	echo "done"
	exit 0
fi

###############################################################################
#
# Load Modules
#

echo "Loading kernel modules ..."

# You should uncomment the line below and run it the first time just to
# ensure all kernel module dependencies are OK.  There is no need to run
# every time, however.

# /sbin/depmod -a

# Unless you have kernel module auto-loading disabled, you should not
# need to manually load each of these modules.  Other than ip_tables,
# ip_conntrack, and some of the optional modules, I've left these
# commented by default.  Uncomment if you have any problems or if
# you have disabled module autoload.  Note that some modules must
# be loaded by another kernel module.

# core netfilter module
/sbin/modprobe ip_tables

# the stateful connection tracking module
/sbin/modprobe ip_conntrack

# filter table module
# /sbin/modprobe iptable_filter

# mangle table module
# /sbin/modprobe iptable_mangle

# nat table module
# /sbin/modprobe iptable_nat

# LOG target module
# /sbin/modprobe ipt_LOG

# This is used to limit the number of packets per sec/min/hr
# /sbin/modprobe ipt_limit

# masquerade target module
# /sbin/modprobe ipt_MASQUERADE

# filter using owner as part of the match
# /sbin/modprobe ipt_owner

# REJECT target drops the packet and returns an ICMP response.
# The response is configurable.  By default, connection refused.
# /sbin/modprobe ipt_REJECT

# This target allows packets to be marked in the mangle table
# /sbin/modprobe ipt_mark

# This target affects the TCP MSS
# /sbin/modprobe ipt_tcpmss

# This match allows multiple ports instead of a single port or range
# /sbin/modprobe multiport

# This match checks against the TCP flags
# /sbin/modprobe ipt_state

# This match catches packets with invalid flags
# /sbin/modprobe ipt_unclean

# The ftp nat module is required for non-PASV ftp support
/sbin/modprobe ip_nat_ftp

# the module for full ftp connection tracking
/sbin/modprobe ip_conntrack_ftp

# the module for full irc connection tracking
/sbin/modprobe ip_conntrack_irc


###############################################################################
#
# Kernel Parameter Configuration
#
# See http://ipsysctl-tutorial.frozentux.net/chunkyhtml/index.html
# for a detailed tutorial on sysctl and the various settings
# available.

# Required to enable IPv4 forwarding.
# Redhat users can try setting FORWARD_IPV4 in /etc/sysconfig/network to true
# Alternatively, it can be set in /etc/sysctl.conf
#if [ "$SYSCTL" = "" ]
#then
#    echo "1" > /proc/sys/net/ipv4/ip_forward
#else
#    $SYSCTL net.ipv4.ip_forward="1"
#fi

# This enables dynamic address hacking.
# This may help if you have a dynamic IP address \(e.g. slip, ppp, dhcp\).
#if [ "$SYSCTL" = "" ]
#then
#    echo "1" > /proc/sys/net/ipv4/ip_dynaddr
#else
#    $SYSCTL net.ipv4.ip_dynaddr="1"
#fi

# This enables SYN flood protection.
# The SYN cookies activation allows your system to accept an unlimited
# number of TCP connections while still trying to give reasonable
# service during a denial of service attack.
if [ "$SYSCTL" = "" ]
then
    echo "1" > /proc/sys/net/ipv4/tcp_syncookies
else
    $SYSCTL net.ipv4.tcp_syncookies="1"
fi

# This enables source validation by reversed path according to RFC1812.
# In other words, did the response packet originate from the same interface
# through which the source packet was sent?  It's recommended for single-homed
# systems and routers on stub networks.  Since those are the configurations
# this firewall is designed to support, I turn it on by default.
# Turn it off if you use multiple NICs connected to the same network.
if [ "$SYSCTL" = "" ]
then
    echo "1" > /proc/sys/net/ipv4/conf/all/rp_filter
else
    $SYSCTL net.ipv4.conf.all.rp_filter="1"
fi

# This option allows a subnet to be firewalled with a single IP address.
# It's used to build a DMZ.  Since that's not a focus of this firewall
# script, it's not enabled by default, but is included for reference.
# See: http://www.sjdjweis.com/linux/proxyarp/ 
#if [ "$SYSCTL" = "" ]
#then
#    echo "1" > /proc/sys/net/ipv4/conf/all/proxy_arp
#else
#    $SYSCTL net.ipv4.conf.all.proxy_arp="1"
#fi

# The following kernel settings were suggested by Alex Weeks. Thanks!

# This kernel parameter instructs the kernel to ignore all ICMP
# echo requests sent to the broadcast address.  This prevents
# a number of smurfs and similar DoS nasty attacks.
if [ "$SYSCTL" = "" ]
then
    echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts
else
    $SYSCTL net.ipv4.icmp_echo_ignore_broadcasts="1"
fi

# This option can be used to accept or refuse source routed
# packets.  It is usually on by default, but is generally
# considered a security risk.  This option turns it off.
if [ "$SYSCTL" = "" ]
then
    echo "0" > /proc/sys/net/ipv4/conf/all/accept_source_route
else
    $SYSCTL net.ipv4.conf.all.accept_source_route="0"
fi

# This option can disable ICMP redirects.  ICMP redirects
# are generally considered a security risk and shouldn't be
# needed by most systems using this generator.
#if [ "$SYSCTL" = "" ]
#then
#    echo "0" > /proc/sys/net/ipv4/conf/all/accept_redirects
#else
#    $SYSCTL net.ipv4.conf.all.accept_redirects="0"
#fi

# However, we'll ensure the secure_redirects option is on instead.
# This option accepts only from gateways in the default gateways list.
if [ "$SYSCTL" = "" ]
then
    echo "1" > /proc/sys/net/ipv4/conf/all/secure_redirects
else
    $SYSCTL net.ipv4.conf.all.secure_redirects="1"
fi

# This option logs packets from impossible addresses.
if [ "$SYSCTL" = "" ]
then
    echo "1" > /proc/sys/net/ipv4/conf/all/log_martians
else
    $SYSCTL net.ipv4.conf.all.log_martians="1"
fi
```


# Authorized SSH keys

Same as https://github.com/alevchuk/minibank#authorized-keys


# Storage (RAID-0)

Same as https://github.com/alevchuk/minibank#btrfs-raid-1-mirror
yet no need to istall anything (skip the `apt` commands)

# Software

## Build Bitcoind

Create bitcoin user unix account
```
sudo /usr/sbin/useradd --system bitcoin
```

Setup symlinks:

https://github.com/alevchuk/minibank#build-bitcoind

(don't proceed to build yet, just the symlinks for now)

Build and install libzmq
```
sudo su -l bitcoin
cd ~/src
git clone https://github.com/zeromq/libzmq.git
git checkout v4.3.3

./autogen.sh
./configure
make clean && make

logout

cd ~bitcoin/src/libzmq
sudo make install
```

the rest is same as https://github.com/alevchuk/minibank/tree/first/bitcoin 
yet no need to install anything (skip the `apt` commands)

make sure the output of bitcoin `configure` returns `with zmq      = yes`

## Start bitcoin

Same as https://github.com/alevchuk/minibank#start-bitcoind
